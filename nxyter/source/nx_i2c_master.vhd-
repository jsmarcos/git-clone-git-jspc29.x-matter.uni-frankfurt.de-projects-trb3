library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.nxyter_components.all;

entity nx_i2c_master is
  generic (
    i2c_speed : unsigned(11 downto 0) := x"3e8"
    );
  port(
    CLK_IN               : in    std_logic;
    RESET_IN             : in    std_logic;

    -- I2C connections
    SDA_INOUT            : inout std_logic;
    SCL_INOUT            : inout std_logic;

    -- Slave bus         
    SLV_READ_IN          : in  std_logic;
    SLV_WRITE_IN         : in  std_logic;
    SLV_DATA_OUT         : out std_logic_vector(31 downto 0);
    SLV_DATA_IN          : in std_logic_vector(31 downto 0);
    SLV_ACK_OUT          : out std_logic;
    SLV_NO_MORE_DATA_OUT : out std_logic;
    SLV_UNKNOWN_ADDR_OUT : out std_logic;
    
    -- Debug Line
    DEBUG_OUT            : out std_logic_vector(15 downto 0)
    );
end entity;

architecture Behavioral of nx_i2c_master is

  signal sda_i : std_logic;
  signal sda_x : std_logic;
  signal sda   : std_logic;

  signal scl_i : std_logic;
  signal scl_x : std_logic;
  signal scl   : std_logic;

  -- I2C Master  
  signal sda_o               : std_logic;
  signal scl_o               : std_logic;
  signal i2c_start           : std_logic;

  signal sda_startstop       : std_logic;
  signal scl_startstop       : std_logic;
  signal startstop_select    : std_logic;
  signal startstop_seq_start : std_logic;
  signal startstop_done      : std_logic;

  signal sda_sendbyte        : std_logic;
  signal scl_sendbyte        : std_logic;
  signal sendbyte_seq_start  : std_logic;
  signal sendbyte_byte       : std_logic_vector(7 downto 0);
  signal sendbyte_done       : std_logic;
  signal sendbyte_ack        : std_logic;

  signal i2c_byte   : unsigned(7 downto 0);
  signal bit_ctr    : unsigned(3 downto 0);
  signal i2c_ack    : std_logic;
  signal i2c_error  : std_logic_vector(3 downto 0);

  type STATES is (S_IDLE,
                  S_START,
                  S_START_WAIT,
                  
                  S_SEND_BYTE,
                  S_SET_SDA,
                  S_SET_SCL,
                  S_UNSET_SCL,
                  S_NEXT_BIT,

                  S_GET_ACK,
                  S_ACK_SET_SCL,
                  S_STORE_ACK,
                  S_ACK_UNSET_SCL,
                  S_VERIFY_ACK,
                  S_ACK_ERROR,
                  
                  S_STOP,
                  S_STOP_WAIT
                  );
  signal STATE : STATES;

  
  -- I2C Timer
  signal wait_timer_init    : unsigned(11 downto 0);
  signal wait_timer_done    : std_logic;
  
  -- TRBNet Slave Bus
  signal slv_data_out_o     : std_logic_vector(31 downto 0);
  signal slv_no_more_data_o : std_logic;
  signal slv_unknown_addr_o : std_logic;
  signal slv_ack_o          : std_logic;
  signal reg_data           : std_logic_vector(31 downto 0);
  signal i2c_chipid         : std_logic_vector(6 downto 0);
  signal i2c_rw_bit         : std_logic;


begin

  -- Timer
  nx_i2c_timer_1: nx_i2c_timer
    port map (
      CLK_IN         => CLK_IN,
      RESET_IN       => RESET_IN,
      TIMER_START_IN => wait_timer_init,
      TIMER_DONE_OUT => wait_timer_done
      );

  -- Start / Stop Sequence
  nx_i2c_startstop_1: nx_i2c_startstop
    generic map (
      i2c_speed => i2c_speed
      )
    port map (
      CLK_IN            => CLK_IN,
      RESET_IN          => RESET_IN,
      START_IN          => startstop_seq_start,
      SELECT_IN         => startstop_select,
      SEQUENCE_DONE_OUT => startstop_done,
      SDA_OUT           => sda_startstop,
      SCL_OUT           => scl_startstop
      );

  nx_i2c_sendbyte_1: nx_i2c_sendbyte
    generic map (
      i2c_speed => i2c_speed
      )
    port map (
      CLK_IN            => CLK_IN,
      RESET_IN          => RESET_IN,
      START_IN          => sendbyte_seq_start,
      BYTE_IN           => sendbyte_byte,
      SEQUENCE_DONE_OUT => sendbyte_done,
      SDA_OUT           => sda_sendbyte,
      SCL_OUT           => scl_sendbyte,
      SDA_IN            => sda,
      ACK_OUT           => sendbyte_ack
      );
  
  -- Debug Line
  DEBUG_OUT(0) <= sda_o;
  DEBUG_OUT(1) <= scl_o;
  DEBUG_OUT(2) <= i2c_start;
  DEBUG_OUT(3) <= wait_timer_done;
  DEBUG_OUT(7 downto 4)  <= i2c_error;

  DEBUG_OUT(15 downto 8) <= (others => '0');
  
  -- Sync I2C Lines
  sda_i <= SDA_INOUT;
  scl_i <= SCL_INOUT;

  PROC_I2C_LINES_SYNC: process(CLK_IN)
  begin
    if( rising_edge(CLK_IN) ) then
      if( RESET_IN = '1' ) then
        sda_x <= '1';
        sda   <= '1';

        scl_x <= '1';
        scl   <= '1';
      else
        sda_x <= sda_i;
        sda   <= sda_x;

        scl_x <= scl_i;
        scl   <= scl_x;
      end if;
    end if;
  end process PROC_I2C_LINES_SYNC;

  PROC_I2C_MASTER: process(CLK_IN)
  begin 
    if( rising_edge(CLK_IN) ) then
      if( RESET_IN = '1' ) then
        sda_o               <= '1';
        scl_o               <= '1';
        wait_timer_init     <= (others => '0');
        bit_ctr             <= (others => '0');
        i2c_ack             <= '0';
        i2c_error           <= (others => '0');
        startstop_select    <= '0';
        startstop_seq_start <= '0';
        STATE <= S_IDLE;
      else
        sda_o <= '1';
        scl_o <= '1';
        wait_timer_init     <= (others => '0');
        startstop_select    <= '0';
        startstop_seq_start <= '0';
        case STATE is
          when S_IDLE =>
            if (i2c_start = '1') then
              STATE <= S_START;
            else
              STATE <= S_IDLE;
            end if;
            
            -- I2C START Sequence 
          when S_START =>
            i2c_ack <= '0';
            startstop_select <= '1';
            startstop_seq_start <= '1';
            STATE <= S_START_WAIT;

          when S_START_WAIT =>
            if (startstop_done = '0') then
              STATE <= S_START_WAIT;
            else
              STATE <= S_SEND_BYTE;
            end if;
                        
            -- I2C Send byte
          when S_SEND_BYTE =>
            bit_ctr <= x"7";
            sda_o   <= '0';
            scl_o   <= '0';
            i2c_byte(7 downto 1) <= i2c_chipid;
            i2c_byte(0)          <= i2c_rw_bit;
            wait_timer_init <= i2c_speed srl 2;
            STATE <= S_SET_SDA;

          when S_SET_SDA =>
            sda_o <= i2c_byte(7);
            scl_o <= '0';
            if (wait_timer_done = '0') then
              STATE <= S_SET_SDA;
            else
              wait_timer_init <= i2c_speed srl 1;
              STATE <= S_SET_SCL;
            end if;

          when S_SET_SCL =>
            sda_o <= i2c_byte(7);
            if (wait_timer_done = '0') then
              STATE <= S_SET_SCL;
            else
              wait_timer_init <= i2c_speed srl 2;
              STATE <= S_UNSET_SCL;
            end if;

          when S_UNSET_SCL =>
            sda_o <= i2c_byte(7);
            scl_o <= '0';
            if (wait_timer_done = '0') then
              STATE <= S_UNSET_SCL;
            else
              STATE <= S_NEXT_BIT;
            end if;
            
          when S_NEXT_BIT =>
            sda_o <= i2c_byte(7);
            scl_o <= '0';
            if (bit_ctr > 0) then
              bit_ctr         <= bit_ctr - 1;
              i2c_byte        <= i2c_byte sll 1;
              wait_timer_init <= i2c_speed srl 2;
              STATE <= S_SET_SDA;
            else
              wait_timer_init <= i2c_speed srl 2;
              STATE <= S_GET_ACK;
            end if;

            -- I2C Check ACK Sequence
          when S_GET_ACK =>
            scl_o <= '0';
            if (wait_timer_done = '0') then
              STATE <= S_GET_ACK;
            else
              wait_timer_init <= i2c_speed srl 2;
              STATE <= S_ACK_SET_SCL;
            end if;

          when S_ACK_SET_SCL =>
            if (wait_timer_done = '0') then
              STATE <= S_ACK_SET_SCL;
            else
              STATE <= S_STORE_ACK;
            end if; 

          when S_STORE_ACK =>
            i2c_ack <= sda;
            wait_timer_init <= i2c_speed srl 2;
            STATE <= S_ACK_UNSET_SCL;
            
          when S_ACK_UNSET_SCL =>
            scl_o <= '0';
            if (wait_timer_done = '0') then
              STATE <= S_ACK_UNSET_SCL;
            else
              STATE <= S_VERIFY_ACK;
            end if;

          when S_VERIFY_ACK =>
            scl_o <= '0';
            if (i2c_ack = '0') then
              STATE <= S_STOP;
            else
              STATE <= S_ACK_ERROR;
            end if;

          when S_ACK_ERROR =>
            scl_o <= '0';
            i2c_error(1) <= '1';
            STATE <= S_STOP;

            -- I2C STOP Sequence 
          when S_STOP =>
            startstop_select <= '0';
            startstop_seq_start <= '1';
            STATE <= S_STOP_WAIT;

          when S_STOP_WAIT =>
            if (startstop_done = '0') then
              STATE <= S_STOP_WAIT;
            else
              STATE <= S_IDLE;
            end if;

        end case;

      end if;
    end if;
  end process PROC_I2C_MASTER;

  -----------------------------------------------------------------------------
  -- TRBNet Slave Bus
  -----------------------------------------------------------------------------

  PROC_SLAVE_BUS: process(CLK_IN)
  begin
    if( rising_edge(CLK_IN) ) then
      if( RESET_IN = '1' ) then
        reg_data           <= x"affeaffe";
        slv_data_out_o     <= (others => '0');
        slv_no_more_data_o <= '0';
        slv_unknown_addr_o <= '0';
        slv_ack_o          <= '0';
        i2c_start          <= '0';
      else
        slv_ack_o <= '1';
        slv_unknown_addr_o <= '0';
        slv_no_more_data_o <= '0';
        slv_data_out_o     <= (others => '0');
        i2c_start          <= '0';
        
        if (SLV_WRITE_IN  = '1') then
          i2c_chipid     <= SLV_DATA_IN(6 downto 0);
          i2c_rw_bit     <= SLV_DATA_IN(7);
          i2c_start      <= '1';
        elsif (SLV_READ_IN = '1') then
          slv_data_out_o     <= reg_data;
          
        else
          slv_ack_o <= '0';
        end if;
      end if;
    end if;           
  end process PROC_SLAVE_BUS;

  -----------------------------------------------------------------------------
  -- Output Signals
  -----------------------------------------------------------------------------

  -- I2c Outputs
  SDA_INOUT <= '0' when (sda_o = '0' or sda_startstop = '0') else 'Z';
  SCL_INOUT <= '0' when (scl_o = '0' or scl_startstop = '0') else 'Z';

  -- Slave Bus
  SLV_DATA_OUT         <= slv_data_out_o;    
  SLV_NO_MORE_DATA_OUT <= slv_no_more_data_o; 
  SLV_UNKNOWN_ADDR_OUT <= slv_unknown_addr_o;
  SLV_ACK_OUT          <= slv_ack_o; 

end Behavioral;
